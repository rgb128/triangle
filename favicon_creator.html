<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Icon Creator</title>
    <style>
        body {
            font-family: sans-serif;
            background-color: #e0e0e0;
            background-image:
                linear-gradient(45deg, #c0c0c0 25%, transparent 25%),
                linear-gradient(-45deg, #c0c0c0 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #c0c0c0 75%),
                linear-gradient(-45deg, transparent 75%, #c0c0c0 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 20px;
            gap: 20px;
        }
        #favicon-canvas {
            border: 2px solid black;
        }
        #download-btn {
            font-size: 16px;
            padding: 10px 20px;
            border: 2px solid black;
            background-color: white;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <canvas id="favicon-canvas"></canvas>
    <button id="download-btn">Download Image</button>

    <script>
        'use strict';

        // --- Configuration ---
        const CANVAS_SIZE = 512;
        // The outer dimension of the square.
        const SQUARE_SIZE = 256 + 128 + 128;
        // The thickness of the square's border.
        const SQUARE_STROKE_WIDTH = 128;
        const FILENAME = 'icon.png';
        // --- End of Configuration ---

        const canvas = document.getElementById('favicon-canvas');
        const downloadBtn = document.getElementById('download-btn');
        const ctx = canvas.getContext('2d');

        /**
         * Draws the final icon by first creating a gradient and then
         * using a hollow square shape as a mask.
         */
        function drawIcon() {
            canvas.width = CANVAS_SIZE;
            canvas.height = CANVAS_SIZE;

            // === STEP 1: Fill the ENTIRE canvas with the color wheel gradient ===
            const centerX = CANVAS_SIZE / 2;
            const centerY = CANVAS_SIZE / 2;
            const gradient = ctx.createConicGradient(0, centerX, centerY);

            gradient.addColorStop(0,    'hsl(0, 100%, 50%)');
            gradient.addColorStop(0.17, 'hsl(60, 100%, 50%)');
            gradient.addColorStop(0.34, 'hsl(120, 100%, 50%)');
            gradient.addColorStop(0.50, 'hsl(180, 100%, 50%)');
            gradient.addColorStop(0.67, 'hsl(240, 100%, 50%)');
            gradient.addColorStop(0.84, 'hsl(300, 100%, 50%)');
            gradient.addColorStop(1,    'hsl(360, 100%, 50%)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);


            // === STEP 2: Make the "useless parts" transparent ===
            // We set the composite operation to 'destination-in'. This means: "Keep the destination
            // (the gradient we just drew), but ONLY where the new source shape is drawn."
            // Everything else on the canvas will be erased (made transparent).
            ctx.globalCompositeOperation = 'destination-in';

            // Now, we draw the "stencil" or "mask" shape. The color doesn't matter, only the shape.
            ctx.fillStyle = 'black'; // Could be any color.

            // First, calculate the geometry of the outer and inner squares
            const outerX = (CANVAS_SIZE - SQUARE_SIZE) / 2;
            const outerY = (CANVAS_SIZE - SQUARE_SIZE) / 2;
            
            const innerSize = SQUARE_SIZE - (SQUARE_STROKE_WIDTH * 2);
            const innerX = outerX + SQUARE_STROKE_WIDTH;
            const innerY = outerY + SQUARE_STROKE_WIDTH;

            // We create the hollow shape by drawing the outer rectangle and then
            // carving out the inner one using the 'evenodd' fill rule.
            ctx.beginPath();
            ctx.rect(outerX, outerY, SQUARE_SIZE, SQUARE_SIZE); // The outer path
            ctx.rect(innerX, innerY, innerSize, innerSize);     // The inner "hole" path
            ctx.fill('evenodd'); // This fills only the space between the two rectangles.

            // (Optional) Reset for any future drawing, which we don't have but is good practice.
            ctx.globalCompositeOperation = 'source-over';
        }

        /**
         * Triggers the download of the canvas content.
         */
        function downloadCanvas() {
            const link = document.createElement('a');
            link.download = FILENAME;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // --- Event Listeners ---
        downloadBtn.addEventListener('click', downloadCanvas);

        // --- Initial Drawing ---
        drawIcon();
    </script>
</body>
</html>
